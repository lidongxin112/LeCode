package com.sort;

import java.util.Arrays;

/**
 * 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，
 * 整个文件恰被分成一组，算法便终止。
 * 简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，
 * 数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。
 * 而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，
 * 继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，
 * 大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。
 * 来看下希尔排序的基本步骤，在此选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择可以用一个序列来表示，
 * {n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，选择的这个增量序列是比较常用的，
 * 也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处做示例使用希尔增量。
 * <p>
 * 最坏时间复杂度 o(n2) 最好o(n) 平均时间复杂度o(n 1.3)
 * 空间复杂度 o(1)
 *
 * @author 东鑫
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = new int[]{10, 6, 3, 8, 33, 27, 66, 9, 7, 88};
        shellSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    private static void shellSort(int[] arr) {
        int temp;
        //控制增量序列,增量序列为1的时候为最后一趟
        for (int i = arr.length / 2; i > 0; i /= 2) {
            //根据增量序列，找到每组比较序列的最后一个数的位置
            for (int j = i; j < arr.length; j++) {
                //根据该比较序列的最后一个数的位置，依次向前执行插入排序
                for (int k = j - i; k >= 0; k -= i) {
                    if (arr[k] > arr[k + i]) {
                        temp = arr[k];
                        arr[k] = arr[k + i];
                        arr[k + i] = temp;
                    }
                }
            }
        }
    }
}
